# 自己对算法的一些总结

## 对算法的
粗浅的自己对算法的理解.

***
## 莫队算法
```text
1. 解决问题: 求解给定区间值的离线算法, 例如 n个数的数组, m个询问, 每个询问求[L, R]之间出现unique的数的个数.
2. 解决思路:
    a. 先定义一个块大小：sqrt(n), 那么一共有n/sqrt(n) = sqrt(n) 个块.
    b. 将查询[L, R]按照下面规则排序:
        i. 先按照L所在的块(L/sqrt(n))排序.
        ii. 如果i中相同，那么按照R排序.
    c. 接下来, 处理每个块中的所有询问:
       le = -1, ri = -1;
       while(le < L) del(le++);
       while(le > L) add(--le);
       while(ri < R) add(++ri);
       while(ri > R) del(ri--);
3. 时间复杂度分析:
    a. 每个块:
         i. le导致的时间复杂度: 每次询问 le 会在一个块内变化 为sqrt(n), m个询问, 所以为sqrt(n)*m.
         ii. ri导致的时间复杂度: 每次询问 ri 递增,最多变化为 n, sqrt(n) 个块，所以为sqrt(n) * n.
    b. 不同block移动导致的时间复杂度:
        i. le block的大小: sqrt(n), 一共sqrt(n) 个块，所以为sqrt(n) * sqrt(n) = n.
        ri. ri 移动为n, 一共sqrt(n),所以为n * sqrt(n).

    所以总的时间复杂度为: sqrt(n) * m + n*sqrt(n) + n + n * sqrt(n).
```

***
## 前缀和与差分
```text
1. 前缀和: sum[i] 等于 sum(a[0], ...., a[i]);
性质: 
   ① a[i] = sum[i] - sum[i - 1];
   ②sum[a[le], a[le + 1], ..., a[ri]) = sum[ri] - sum[le - 1];

二维前缀和: sum[i][j] = (a[0][0], .....a[i][j]) 的矩形的和.
性质：     sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + a[i][j]
   
2. 差分:
   给定数组:a[0], a[1], ..., a[n - 1],
   数组: b[0~n-1], 其中b[0] = a[0], 当 i > 0 && i < n时, b[i] = b[i] - b[i - 1]
       b 数组即为 a数组的差分.

性质：① sum[b[0]~b[i]] = a[i];
     ② 对区间a[le]-a[ri] 的每个元素全部操作，例如每个元素加一，在差分上的体现就是b[le] += 1, b[ri + 1] -= 1; 这是极其重要的性质！！！ 把o(n) 复杂度降低为o(1);

二维差分：
     b[i][j]:   sum[b[0][0].....b[i][j]] = a[i][j];
性质：①对于矩形(x1, y1)(x2, y2) 的批量操作,例如加1， 体现在差分数组就是:
       b[x1][y1] += 1;
       b[x1][y2 + 1] -= 1;
       b[x2 + 1][y1] -= 1;
       b[x2 + 1][y2 + 1] += 1;

具体前缀和与差分练习题： https://vjudge.net/contest/440752#overview
```

***

## 图的基本概念
```text
图的种类: 有向图 和 无向图.

无向图的术语:
1. 连通图：任意两点之间都有路径连接的图叫做连通图.
2. 树: 没有圈的连通图叫做树. (一棵树的边数恰好是顶点数-1)

有向图的术语:
1. 没有圈的有向图叫做DAG(directed acyclic graph)
```

### 割边 && 割点.
```text
=======
#### 割点 与割边(桥)
```text
1. 割点：无向连通图中, 去掉一个顶点及它相邻的所有边, 图中的连通分量增加, 那么该点为割点.
2. 桥(割边):无向联通图中，去掉一条边，图中的连通分量数增加，则这条边，称为桥或者割边。

割边与割点的关系：
1. 有割点不一定有桥，有桥一定有割点.
2. 桥一定是割点依附的边.
 
割点的求法：
  1. 令dnf[from] 代表dfs 到from这个节点的时间序列.
  2. 令low[from] 代表 from 这个节点的子节点可以到达的时间序列最小的点.
  那么：①所有的割点的dnf[from] == low[from].
       ②如果low[to] > dnf[from], 那么 from->to 为一条割边.

```

### 二分图的判定
```
把相邻顶点染成不同颜色的问题叫做图着色问题,对图进行染色是所需要的最小颜色数称为最小着色数, 最小着色数是2的图称为二分图. （图可以是不连通的）  
方法: 遍历每一个没有被着色的点, 给一个颜色DFS进行着色尝试.
```

### 最短路问题
```
1. Bellman-Ford 算法
    求一个点到其他所有点的最短路问题, 注意有负环的存在. 一共n的点, 哪里理论上.最多更新n-1次, 如果超过n-1次还有更新，那么就是有负环.

2. disjkstra 算法
   1. 找到没有被访问过的最短路径的点. (这个地方是可以优化的点, 可以用o(n)遍历，也可以用优先队列来log(n)查找)
   2. 标记此点为访问过.
   3. 更新此点周围的点.

3. 任意两点间的最短路问题. (Floyd-warshall 算法)

问题：次短路径怎么算：算出每一个点的最短路径和次短路径, 对disjkstra 改造就行.
```

### 最小生成树
```
解决的问题: 给一个无向图, 如果她的任何子图中任意两个顶点都互相连通并且是一棵树, 那么这棵树就叫做生成树, 如果边上有权值, 那么使得边权和最小的生成树叫做最小生成树.

1. Prime 算法 
    a. 寻找与被标记节点相连的最短路径的非标记节点。
    b. 标记这个节点
    c. 把路径加入最小生成树的路径和中.

2. kruskal 算法
    a. 将边按照权重排序.
    b. 用并查集来判断是否加入到最小生成树中.

```



